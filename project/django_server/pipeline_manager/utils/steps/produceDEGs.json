{
    "executables": [
        {
            "command": "from optparse import OptionParser\nimport os\nfrom subprocess import Popen\nimport sys\nimport math\n\ndef create_fold_change_table(gene_count_file, outputdir, phenodata_file, covariate, subset=None, control_name=None):\n    command_args = [\"-i\", gene_count_file, \"-o\", outputdir, \"-p\", phenodata_file, \"-t\", \",\", \"-v\", covariate]\n    if control_name is not None: command_args += [\"-n\", control_name]\n    if subset is not None: command_args += [\"-s\", subset]\n    \n    print(\"Invoking create_foldchange_table.R\")\n    proc = Popen([\"Rscript\", \"create_foldchange_table.R\"] + command_args)\n    proc.wait()\n    print(\"Return code = {}\".format(proc.returncode))\n    if proc.returncode != 0: print(\"[STATUS] ERROR \", command_args)\n    else: print(\"[STATUS] OK \", command_args)\n\ndef create_degs(gene_count_file, outputdir, phenodata_file, covariate, control_name=None, subset=None, logfoldchange=1, qvalue=0.05):\n    \n    command_args = [\"-i\", gene_count_file, \"-o\", outputdir, \"-p\", phenodata_file, \"-t\", \",\", \"-v\", covariate, \"-f\", logfoldchange, \"-q\", qvalue]\n    if control_name is not None: command_args += [\"-n\", control_name]\n    if subset is not None: command_args += [\"-s\", subset]\n\n    print(\"Invoking produce_DEG_table.R\")\n    proc = Popen([\"Rscript\", \"produce_DEG_table.R\"] + command_args)\n    proc.wait()\n    print(\"Return code = {}\".format(proc.returncode))\n    if proc.returncode != 0: print(\"[STATUS] ERROR \", command_args)\n    else: print(\"[STATUS] OK \", command_args)\n\ndef create_ontology(gene_count_file, outputdir, phenodata_file, covariate, control_name=None, subset=None, organism_model=None, organism_db=None, logfoldchange=1, qvalue=0.05):\n    command_args = [\"-i\", gene_count_file, \"-o\", outputdir, \"-p\", phenodata_file, \"-t\", \",\", \"-v\", covariate, \"-f\", logfoldchange, \"-q\", qvalue]\n    if control_name is not None: command_args += [\"-n\", control_name]\n    if subset is not None: command_args += [\"-s\", subset]\n    if organism_model is not None and organism_db is not None: command_args += [\"-m\", organism_model, \"-d\", organism_db]\n\n    print(\"Invoking create_ontology_tables.R\")\n    proc = Popen([\"Rscript\", \"create_ontology_tables.R\"] + command_args)\n    proc.wait()\n    print(\"Return code = {}\".format(proc.returncode))\n    if proc.returncode != 0: print(\"[STATUS] ERROR \", command_args)\n    else: print(\"[STATUS] OK \", command_args)\n    \ndef create_degs_for_subset_file(combination_file, indir, outdir, control_name, organism_model, organism_db):\n    \n    if not outdir.endswith(\"/\"): outdir += \"/\"\n    \n    with open(combination_file, \"r\") as reader:\n        for line in reader:\n            if len(line) == 0: break\n            if line.startswith(\"#\"): continue\n          \n            pieces = line.split(\"\\t\")\n            \n            ID = pieces[0]\n            bioproject = pieces[1]\n            subset = pieces[2]\n            covariate = pieces[3]\n          \n    #       if ID != \"PRJNA401858_0\": continue\n          \n            print(\"#########\")\n            print(bioproject)\n            print(subset)\n            print(covariate)\n            print(ID)\n            \n            print(\"Processing configuration {}\".format(ID))\n            if not os.path.exists(indir + bioproject):\n                print(\"MISSING DATA\", indir + bioproject)\n                continue\n            \n            #Load gene(/transcript) count matrix and labels\n            gene_count_file = indir + bioproject + \"/\" + \"gene_count_matrix.csv\"\n            phenodata_file = indir + bioproject + \"/\" + \"phenodata.csv\"\n            \n            outputdir = outdir + ID + \"/\"\n            if not os.path.exists(outputdir):\n                os.makedirs(outputdir)\n#                 create_fold_change_table(gene_count_file, outputdir, phenodata_file, covariate, subset, control_name)\n            \n            couples = zip([\"{:.2f}\".format(math.log(x * 0.1, 2)) for x in range(10, 21, 1)], [\"0.05\"]*11)\n            for couple in couples:\n                 \n                fulloutputdir = outdir + ID + \"/lfc\" + couple[0] + \"-q\" + couple[1] + \"/\"\n                if not os.path.exists(fulloutputdir):\n                    os.makedirs(fulloutputdir)\n                else:\n                    print(\"SKIPPING\", fulloutputdir)\n                    continue\n                 \n                print(\"Analyzing \" + str(couple) + \" for subset \" + subset)\n                create_degs(gene_count_file, fulloutputdir, phenodata_file, covariate, control_name, subset, couple[0], couple[1])\n#                 create_ontology(gene_count_file, fulloutputdir, phenodata_file, covariate, control_name, subset, organism_model, organism_db, couple[0], couple[1])\n            \n            \n#             raw_input(\"Press any key to analyze next subset...\")\n            \n            print(\"Differential data for configuration {} produced.\".format(ID))\n\n# Real-world invocation command line:\n#\n# python produce_lists_deseq2.py -n \"control\" -f data/configurations.tsv -i data/ -o output_final_4/ -m \"Mus musculus\" -d \"org.Mm.eg.db\"\n\nif __name__ == '__main__':\n\n    opt_parser = OptionParser()\n    \n    opt_parser.add_option(\"-f\", \"--combination_file\", default=None, help=\"File name containing the combinations\")\n    opt_parser.add_option(\"-i\", \"--indir\", help=\"Input directory name with data for all bioprojects [default= %default]\")\n    opt_parser.add_option(\"-o\", \"--outdir\", default=\"out/\", help=\"Output directory name [default= %default]\")\n    opt_parser.add_option(\"-n\", \"--control_name\", help=\"Label for control condition\")\n    opt_parser.add_option(\"-m\", \"--organism\", help=\"Organism name\")\n    opt_parser.add_option(\"-d\", \"--organism_db\", help=\"Organism DB\")\n    \n    (opt, args) = opt_parser.parse_args()\n    \n    if not opt.combination_file:\n        opt_parser.print_help()\n        exit(\"Please provide a configuration input file. [--combination_file]\")\n      \n    if not opt.indir:\n        opt_parser.print_help()\n        exit(\"Please provide an input directory with the input data. [--indir]\")\n    \n    create_degs_for_subset_file(opt.combination_file, opt.indir, opt.outdir, opt.control_name, opt.organism, opt.organism_db)", 
            "filename": "produce_lists_deseq2.py"
        }, 
        {
            "command": "#!/usr/bin/env Rscript\n\nlibrary(\"optparse\")\n\n###################################\n#######  PARSING OPTIONS #########\n###################################\noption_list = list(\n    make_option(c(\"-p\", \"--phenodata\"), type=\"character\", default=NULL, help=\"Phenodata file path\", metavar=\"character\"),\n    make_option(c(\"-o\", \"--outdir\"), type=\"character\", default=\"out/\", help=\"Output directory (must exist at launch time) [default= %default]\", metavar=\"character\"),\n    make_option(c(\"-i\", \"--gene_counts\"), type=\"character\", default=\"gene_count_matrix.csv\", help=\"output directory [default= %default]\", metavar=\"character\"),\n    make_option(c(\"-v\", \"--var_to_test\"), type=\"character\", help=\"the variable/column to test against\", metavar=\"character\"),\n    make_option(c(\"-n\", \"--control_name\"), type=\"character\", help=\"the name of controls inside the variable/column to test against\", metavar=\"character\"),\n    make_option(c(\"-s\", \"--subset\"), type=\"character\", help=\"Boolean formula to subset the input data\", metavar=\"character\")\n);\n\nopt_parser = OptionParser(option_list=option_list);\nopt = parse_args(opt_parser);\n\nif (is.null(opt$phenodata))\n    stop(\"Phenodata parameter must be provided (-p). See script usage (--help)\")\n\nif (is.null(opt$outdir))\n    stop(\"Output directory parameter must be provided (-o). See script usage (--help)\")\n\nif (is.null(opt$var_to_test))\n    stop(\"Variable to test parameter must be provided (-v). See script usage (--help)\")\n    \nif (is.null(opt$control_name)){\n    print(\"Using lexicographic order of values in column VAR_TO_TEST instead of custom label (e.g., 'control') for differential analysis\")\n} else {\n    print(paste(\"Using\", opt$control_name, \"as control value for differential analysis\"))\n}\n\nPHENO_DATA = opt$phenodata\nPATH = opt$outdir\nif (is.null(PATH)) PATH = \"./\"\nGENE_COUNTS = opt$gene_counts\nVAR_TO_TEST = opt$var_to_test\nSUBS = opt$subset\nCONTROL_NAME = opt$control_name\n\n\n# Saving parameters to file\nwrite.table(t(as.data.frame(opt)), file=paste(PATH, \"parameters.txt\", sep=\"\"))\n\nlibrary(\"DESeq2\")\n\n###################################\n#######  DATA IMPORT ##############\n###################################\nprint(paste(\"Reading gene counts from \", GENE_COUNTS))\n\ncountData <- as.matrix(read.csv(GENE_COUNTS, row.names=\"gene_id\"))\ncolData <- read.csv(PHENO_DATA, sep=\",\", row.names=1)\n\n#qualche check preliminare. Devo avere due TRUE per poter continuare:\nall(rownames(colData) %in% colnames(countData))\n#[1] TRUE\ncountData <- countData[, rownames(colData)]\nall(rownames(colData) == colnames(countData))\n#[1] TRUE\n\n\n###################################\n#######  DATA SUBSET AND PRE-FILTERING ##############\n###################################\n\n## costruisco a monte la stringa per il subset che abbia un aspetto come questa:\n## SUBS <- quote(condition==\"drought\" | condition==\"watered\")\nif (! is.null(SUBS) )\n{\n#Posso cos\u00ec subsettare phenodata e matrice di conta:\ncolData_filt <- subset(colData, eval(parse(text = SUBS)))\ncountData_subs <- countData[,colnames(countData) %in% rownames(colData_filt)]\n} else {\ncolData_filt = colData\ncountData_subs = countData\n}\n\n#Removing genes whose mean expression across samples  is less than 5 FPKM\ncountData_filt <-  countData_subs[rowMeans(countData_subs)>=5,]\n\n##Questo relevel non \u00e8 sempre fondamentale. Si pu\u00f2 saltare se non c'\u00e8 un vero e proprio campione di controllo (ad. es Pioppo, maiale). E' importante perch\u00e9 il segno del FC dipende da chi si trova al denominatore. Va invece utilizzato ad esempio nel caso dello stress laddove il valore di riferimento DEVE essere \"control\".\nif ( ! is.null(CONTROL_NAME) )\ncolData_filt[[VAR_TO_TEST]] <- relevel(colData_filt[[VAR_TO_TEST]], ref = CONTROL_NAME)\n\n###################################\n#######  DESeq2 ANALYSIS ###########\n###################################\n\n# Create a DESeqDataSet from count matrix and labels\n# (bisogna ricostruire nuovamente l'oggetto DESeq ogni volta che si cambia il design!)\ndds <- DESeqDataSetFromMatrix(countData = countData_filt, colData = colData_filt, design = as.formula(paste(\"~\", VAR_TO_TEST)))\n\n# Run the default analysis for DESeq2 and generate results table\ndds <- DESeq(dds)\nres <- results(dds)\n\n# Sort and filt  by adjusted p-value:\nresOrdered <- res[order(res$padj), ]\n\n###################################\n#########  DATA SAVE  ##############\n###################################\n\n#####################################################\n### Compose the output file's name in a parametric manner. ###\n#####################################################\n# This string gives a short summary of the tested categories and I parse and use it in the output's name:\ntested_cat <- resOrdered@elementMetadata@listData$description[5]\ntested_cat <- gsub(\"Wald test p-value: \", \"\" , tested_cat)\n \n# Exporting NOT filtered results:\nwrite.csv(as.data.frame(resOrdered), file=paste(PATH, paste(\"gene_expr-\", gsub(\" \",\"_\",tested_cat), \".csv\", sep=\"\"), sep=\"\"))\n\n\n#############################################\n#########  Distance Matrix heatmap  ##############\n#############################################\nlibrary(ggplot2)\n\n# Figure out how much the replicates look like each other:\nlibrary(reshape2)\nlibrary(pheatmap)\n\n# Transform count data using the variance stabilizing transform:\ndeseq2VST <- vst(dds)\nlibrary(\"RColorBrewer\")\n\n# Convert the DESeq transformed object to a data frame\ndeseq2VST <- assay(deseq2VST)\ndeseq2VST <- as.data.frame(deseq2VST)\ndeseq2VST$Gene <- rownames(deseq2VST)\n\n# First compare wide vs long version\ndeseq2VST_wide <- deseq2VST\ndeseq2VST_long <- melt(deseq2VST, id.vars=c(\"Gene\"))\ndeseq2VST <- melt(deseq2VST, id.vars=c(\"Gene\"))\n\n# Make a heatmap\nvsd <- vst(dds, blind=FALSE)\nrld <- rlog(dds, blind=FALSE) #normalizza i valori di count data e li trasforma in log2\n# Create distance matrix:\nsampleDists <- dist(t(assay(vsd)))\nsampleDistMatrix <- as.matrix(sampleDists)\ncolnames(sampleDistMatrix) <- NULL\n\n# Save distance matrix:\ncolors <- colorRampPalette( rev(brewer.pal(9, \"Blues\")) )(255)\nheat <- pheatmap(sampleDistMatrix, clustering_distance_rows=sampleDists, clustering_distance_cols=sampleDists, col=colors)\nggsave(file=paste(PATH, \"Heatmap_sample_distances.png\", sep=\".\"), heat)", 
            "filename": "create_foldchange_table.R"
        }, 
        {
            "command": "#!/usr/bin/env Rscript\n\nlibrary(\"optparse\")\n\n###################################\n#######  PARSING OPTIONS #########\n###################################\noption_list = list(\n    make_option(c(\"-p\", \"--phenodata\"), type=\"character\", default=NULL, help=\"Phenodata file path\", metavar=\"character\"),\n\tmake_option(c(\"-t\", \"--separator\"), type=\"character\", default=\"\\t\", help=\"Separator for phenodata file (e.g., ',' for csv files, '\\t' for tsv files, etc.) [default= %default]\", metavar=\"character\"),\n    make_option(c(\"-o\", \"--outdir\"), type=\"character\", default=\"out/\", help=\"Output directory (must exist at launch time) [default= %default]\", metavar=\"character\"),\n    make_option(c(\"-i\", \"--gene_counts\"), type=\"character\", default=\"gene_count_matrix.csv\", help=\"output directory [default= %default]\", metavar=\"character\"),\n    make_option(c(\"-v\", \"--var_to_test\"), type=\"character\", help=\"the variable/column to test against\", metavar=\"character\"),\n    make_option(c(\"-n\", \"--control_name\"), type=\"character\", help=\"the name of controls inside the variable/column to test against\", metavar=\"character\"),\n    make_option(c(\"-q\", \"--padjusted\"), type=\"double\", default=0.05, help=\"p-adjusted threshold value [default= %default]\", metavar=\"QVALUE\"),\n    make_option(c(\"-f\", \"--log_fold_change\"), type=\"double\", default=1, help=\"fold-change threshold value [default= %default]\", metavar=\"FOLD_CHANGE_THRESHOLD\"),\n    make_option(c(\"-s\", \"--subset\"), type=\"character\", help=\"Boolean formula to subset the input data (e.g., Treatment.2='ELS-late_postnatal')\", metavar=\"character\")\n);\n\nopt_parser = OptionParser(option_list=option_list);\nopt = parse_args(opt_parser);\n\nif (is.null(opt$phenodata))\n    stop(\"Phenodata parameter must be provided (-p). See script usage (--help)\")\n\nif (is.null(opt$outdir))\n    stop(\"Output directory parameter must be provided (-o). See script usage (--help)\")\n\nif (is.null(opt$var_to_test))\n    stop(\"Variable to test parameter must be provided (-v). See script usage (--help)\")\n\nif (is.null(opt$control_name)){\n    print(\"Using lexicographic order of values in column VAR_TO_TEST instead of custom label (e.g., 'control') for differential analysis\")\n} else {\n    print(paste(\"Using\", opt$control_name, \"as control value for differential analysis\"))\n}\n    \nPHENO_DATA = opt$phenodata\nSEPARATOR = opt$separator\nPATH = opt$outdir\nif (is.null(PATH)) PATH = \"./\"\nGENE_COUNTS = opt$gene_counts\nVAR_TO_TEST = opt$var_to_test\nSUBS = opt$subset\nCONTROL_NAME = opt$control_name\nPADJ = opt$padjusted                 #Set the PADJ value cutoff\nFC_THR = opt$log_fold_change            #Set the log2FC value cutoff\n\n# Saving parameters to file\nwrite.table(t(as.data.frame(opt)), file=paste(PATH, \"parameters.txt\", sep=\"\"))\n\nlibrary(\"DESeq2\")\n\n###################################\n#######  DATA IMPORT ##############\n###################################\nprint(\"#######  DATA IMPORT ##############\")\nprint(paste(\"Reading gene counts from \", GENE_COUNTS))\ncountData <- as.matrix(read.csv(GENE_COUNTS, row.names=\"gene_id\"))\n\nprint(paste(\"Reading phenodata form \", PHENO_DATA))\ncolData <- read.csv(PHENO_DATA, sep=SEPARATOR, row.names=1)\n\n#qualche check preliminare. Devo avere due TRUE per poter continuare:\nprint(\"Do phenodata and gene count matrix refer to the same set of samples?\")\nall(rownames(colData) %in% colnames(countData))\n#[1] TRUE\ncountData <- countData[, rownames(colData)]\nall(rownames(colData) == colnames(countData))\n#[1] TRUE\n\n\n###################################\n#######  DATA SUBSET AND PRE-FILTERING ##############\n###################################\n\n## costruisco a monte la stringa per il subset che abbia un aspetto come questa:\n## SUBS <- quote(condition==\"drought\" | condition==\"watered\")\nif (! is.null(SUBS) )\n{\n#Posso cos\u00ec subsettare phenodata e matrice di conta:\ncolData_filt <- subset(colData, eval(parse(text = SUBS)))\ncountData_subs <- countData[,colnames(countData) %in% rownames(colData_filt)]\n} else {\ncolData_filt = colData\ncountData_subs = countData\n}\n\nlibrary(genefilter)\n\n#filtering:\nprint(\"####### DATASET PRE-FILTERING ###########\")\nprint(\"Removing genes whose mean expression is less than 5 FPKM in at least 80% of the samples\")\n#Define a function to remove genes whose mean expression is less than 5 in at least 80% of the samples:\nfun <- kOverA(round(dim(colData_filt)[1]*80/100),5)\n#Apply it to my matrix:\nfilter1 <-  apply( countData_subs, 1, fun)\ncountData_filt <- countData_subs[filter1,]\n\n\n\n\n##Questo relevel non \u00e8 sempre fondamentale. Si pu\u00f2 saltare se non c'\u00e8 un vero e proprio campione di controllo (ad. es Pioppo, maiale). E' importante perch\u00e9 il segno del FC dipende da chi si trova al denominatore. Va invece utilizzato ad esempio nel caso dello stress laddove il valore di riferimento DEVE essere \"control\".\nif ( ! is.null(CONTROL_NAME) )\ncolData_filt[[VAR_TO_TEST]] <- relevel(colData_filt[[VAR_TO_TEST]], ref = CONTROL_NAME)\n\n###################################\n#######  DESeq2 ANALYSIS ###########\n###################################\n\n# Create a DESeqDataSet from count matrix and labels\n# (bisogna ricostruire nuovamente l'oggetto DESeq ogni volta che si cambia il design!)\nprint(\"#######  DESeq2 ANALYSIS ###########\")\ndds <- DESeqDataSetFromMatrix(countData = countData_filt, colData = colData_filt, design = as.formula(paste(\"~\", VAR_TO_TEST)))\n\n# Run the default analysis for DESeq2 and generate results table\ndds <- DESeq(dds)\nres <- results(dds)\n#add an extra column to mark outliers:\nres$outlier = res$baseMean > 0 & is.na(res$pvalue)\n\n# Computing and Exporting only the results which pass an adjusted p value threshold and a particular FC value:\n# First of all, we need to subset the matrix:\nprint(\"Subsetting dataset\")\nresSig <- subset(res, padj < PADJ & abs(log2FoldChange)>=FC_THR)\n#sort and show by FC value:\nresSig <- resSig[order(abs(resSig$log2FoldChange),decreasing=T), ]\n\n###################################\n#########  DATA SAVE  ##############\n###################################\n\n#####################################################\n### Compose the output file's name in a parametric manner. ###\n#####################################################\n# This string gives a short summary of the tested categories and I parse and use it in the output's name:\ntested_cat <- resSig@elementMetadata@listData$description[5]\ntested_cat <- gsub(\"Wald test p-value: \", \"\" , tested_cat)\n\nCONDITION_STRING = paste(\"qvalue\", PADJ, \"log2FC\", FC_THR, gsub(\" \",\"_\",tested_cat), sep=\".\")\n\n# Exporting filtered results:\nwrite.csv(as.data.frame(resSig), file=paste(PATH, \"DEGs-\", CONDITION_STRING, \".csv\", sep=\"\"))\n\nprint(\"Written table of DEGs\")\n\n##HTML Report creation:\nlibrary(\"ReportingTools\")\nhtmlRep <- HTMLReport(shortName=\"report\", title=\"My report\", reportDirectory=\"html\", basePath=PATH)\npublish(as.data.frame(resSig), htmlRep)\nurl <- finish(htmlRep)\n\n\n###################################\n######### GRAPHICAL PART #########\n###################################\n\nprint(\"######### GRAPHICAL PART #########\")\n\n#plotto in un unico grafico le conte di espressione nei DEGs (ne riporto fino a 10) divisi per VAR_TO_TEST:\nprint(paste(\"I'm plotting the counts for the genes in the toptable of DEGs, dividing sample groups by \", VAR_TO_TEST))\nif(nrow(resSig)!=0 & nrow(resSig)<=10)\n{\nloop.vector<-rownames(resSig)\nprint(loop.vector)\nprint(paste(PATH, \"toptable_DEGs-plot_counts_by_\", VAR_TO_TEST , \".png\", sep=\"\"))\npng(file=paste(PATH, \"toptable_DEGs-plot_counts_by_\", VAR_TO_TEST , \".png\", sep=\"\"), res=100)\npar(mfrow = c(2, 5))\nplotcounts <- for (i in loop.vector) {plotCounts(dds,i, intgroup = VAR_TO_TEST)}\ndev.off()\n} else {\nloop.vector<-rownames(resSig)[c(1:10)]\npng(file=paste(PATH, \"toptable_DEGs-plot_counts_by_\", VAR_TO_TEST , \".png\", sep=\"\"), res=100)\npar(mfrow = c(2, 5))\nplotcounts <- for (i in loop.vector) {plotCounts(dds,i, intgroup = VAR_TO_TEST)}\ndev.off()\n}\n\n\nprint(\"loading ggplot2 package\")\nlibrary(ggplot2)\n\n# Vulcano plot on DEGs samples:\ntoptable <- as.data.frame(res)\n\nEnhancedVolcanoDESeq2 <- function(toptable, AdjustedCutoff=PADJ, LabellingCutoff=PADJ, FCCutoff=FC_THR, main=\"VolcanoPlot\")\n{\n  toptable$Significance <- \"NS\"\n  toptable$Significance[(abs(toptable$log2FoldChange) > FCCutoff)] <- \"FC\"\n  toptable$Significance[(toptable$padj<AdjustedCutoff)] <- \"FDR\"\n  toptable$Significance[(toptable$padj<AdjustedCutoff) & (abs(toptable$log2FoldChange)>FCCutoff)] <- \"FC_FDR\"\n  table(toptable$Significance)\n  toptable$Significance <- factor(toptable$Significance, levels=c(\"NS\", \"FC\", \"FDR\", \"FC_FDR\"))\n\n  plot <- ggplot(toptable, aes(x=log2FoldChange, y=-log10(padj))) +\n    #scale_y_continuous(breaks = seq(0, 150, by = 25)) +\n    #axis.break(axis=1,breakpos=100,pos=NA,bgcol=\"white\",breakcol=\"black\", style=\"slash\",brw=0.02)\n    \n    #Add points:\n    #   Colour based on factors set a few lines up\n    #   'alpha' provides gradual shading of colour\n    #   Set size of points\n    geom_point(aes(color=factor(Significance)), alpha=1/2, size=0.8) +\n\n    #Choose which colours to use; otherwise, ggplot2 chooses automatically (order depends on how factors are ordered in toptable$Significance)\n    scale_color_manual(values=c(NS=\"grey30\", FC=\"forestgreen\", FDR=\"royalblue\", FC_FDR=\"red2\"), labels=c(NS=\"NS\", FC=paste(\"LogFC>|\", FCCutoff, \"|\", sep=\"\"), FDR=paste(\"FDR Q<\", AdjustedCutoff, sep=\"\"), FC_FDR=paste(\"FDR Q<\", AdjustedCutoff, \" & LogFC>|\", FCCutoff, \"|\", sep=\"\"))) +\n\n    #Set the size of the plotting window\n    theme_bw(base_size=24) +\n\n    #Modify various aspects of the plot text and legend\n    theme(legend.background=element_rect(),\n          plot.title=element_text(angle=0, size=12, face=\"bold\", vjust=1),\n\n          panel.grid.major=element_blank(), #Remove gridlines\n          panel.grid.minor=element_blank(), #Remove gridlines\n\n          axis.text.x=element_text(angle=0, size=12, vjust=1),\n          axis.text.y=element_text(angle=0, size=12, vjust=1),\n          axis.title=element_text(size=12),\n\n          #Legend\n          legend.position=\"top\",            #Moves the legend to the top of the plot\n          legend.key=element_blank(),       #removes the border\n          legend.key.size=unit(0.5, \"cm\"),  #Sets overall area/size of the legend\n          legend.text=element_text(size=8), #Text size\n          title=element_text(size=8),       #Title text size\n          legend.title=element_blank()) +       #Remove the title\n\n    #Change the size of the icons/symbols in the legend\n    guides(colour = guide_legend(override.aes=list(size=2.5))) +\n\n    #Set x- and y-axes labels\n    xlab(bquote(~Log[2]~ \"fold change\")) +\n    ylab(bquote(~-Log[10]~adjusted~italic(P))) +\n\n    #Set the axis limits\n    #xlim(-6.5, 6.5) +\n    #ylim(0, 100) +\n\n    #Set title\n    ggtitle(main) +\n\n    #Tidy the text labels for a subset of genes\n    geom_text(data=subset(toptable, padj<LabellingCutoff & abs(log2FoldChange)>FCCutoff),\n              aes(label=rownames(subset(toptable, padj<LabellingCutoff & abs(log2FoldChange)>FCCutoff))),\n              size=2.25,\n              #segment.color=\"black\", #This and the next parameter spread out the labels and join them to their points by a line\n              #segment.size=0.01,\n              check_overlap=TRUE,\n              vjust=1.0) +\n\n    #Add a vertical line for fold change cut-offs\n    geom_vline(xintercept=c(-FCCutoff, FCCutoff), linetype=\"longdash\", colour=\"black\", size=0.4) +\n\n    #Add a horizontal line for P-value cut-off\n    geom_hline(yintercept=-log10(AdjustedCutoff), linetype=\"longdash\", colour=\"black\", size=0.4)\n\n  return(plot)\n}\n\n# Create and save the volcano plot (if the matrix contains rows):\nif(nrow(toptable)!=0)\n{\nprint(\"Table of DEGs contains results: I'm plotting a volcano plot\")\nvolc <- EnhancedVolcanoDESeq2(toptable, AdjustedCutoff=PADJ, LabellingCutoff=PADJ, FCCutoff=FC_THR, main=paste(\"Volcano Plot of differentially expressed genes\", gsub(\" \",\"_\",tested_cat), sep=\"\\n\"))\nggsave(file=paste(PATH, \"DEGs_volcanoplot-\", CONDITION_STRING, \".png\", sep=\"\"), volc)\n} else {\nprint(\"Table of DEGs does not contain any results: No volcano plot produced\")\n}\n\n#############################################\n#########  Heatmap with DEG  ##################\n#############################################\n\n# DEG heatmap:\nprint(\"Loading R packages for heatmap\")\nprint(\"Producing a heatmap with DEGs\")\nlibrary(pheatmap)\nlibrary(gplots)\ndeseq2VST <- vst(dds)\ndeseq2VST <- assay(deseq2VST)   \ncolnames(deseq2VST) <- colData_filt[[VAR_TO_TEST]]\n\n# Extract the rows you want by indexing, you just need to create a vector of the genes you want to pull out. For example:\nidx <- rownames(res)[ which(res$padj < PADJ & abs(res$log2FoldChange)>=FC_THR) ]\n\nif(nrow(deseq2VST[ idx, ])!=0)\n{\nprint(paste(\"the number of rows for the heatmap input matrix is \",nrow(deseq2VST[ idx, ])))\nprint(\"Producing a heatmap on DEGs\")\ndeg_heat <- pheatmap(deseq2VST[ idx, ],scale = \"row\", clustering_distance_rows = \"correlation\", clustering_method = \"complete\")\npng(file=paste(PATH, \"DEGs_heatmap-\", CONDITION_STRING, \".png\", sep=\"\"))\nprint(deg_heat)\ndev.off()\n} else {\nprint(paste(\"the number of rows for the heatmap input matrix is \",nrow(deseq2VST[ idx, ])))\nprint(\"table of DEGs is empty or it is not a dataframe: no heatmap will be produced\")\n}\n\n\n\n#############################################\n############ Matrix MAplot  ###################\n#############################################\n\n# MAplot:\n#plotMA(res, cex=0.8, alpha=PADJ)\n#ggsave(file=paste(PATH, \"DEGs_MAplot-\", CONDITION_STRING, \".png\", sep=\"\"))", 
            "filename": "produce_DEG_table.R"
        }, 
        {
            "command": "#!/usr/bin/env Rscript\n\nlibrary(\"optparse\")\n\n###################################\n#######  PARSING OPTIONS #########\n###################################\n\n# Real life launch: Rscript create_ontology.R -p phenodata_deseq2.tsv -i gene_count_matrix.csv -v Stress.protocol -o output -n control -m Mus_musculus -d org.Mm.eg.db\n\noption_list = list(\n    make_option(c(\"-p\", \"--phenodata\"), type=\"character\", default=NULL, help=\"Phenodata file path\", metavar=\"character\"),\n      make_option(c(\"-t\", \"--separator\"), type=\"character\", default=\"\\t\", help=\"Separator for phenodata file (e.g., ',' for csv files, '\\t' for tsv files, etc.) [default= %default]\", metavar=\"character\"),\n    make_option(c(\"-o\", \"--outdir\"), type=\"character\", default=\"out/\", help=\"Output directory (warning! MUST exist at launch time) [default= %default]\", metavar=\"character\"),\n    make_option(c(\"-i\", \"--gene_counts\"), type=\"character\", default=\"gene_count_matrix.csv\", help=\"output directory [default= %default]\", metavar=\"character\"),\n    make_option(c(\"-v\", \"--var_to_test\"), type=\"character\", help=\"the variable/column to test against\", metavar=\"character\"),\n    make_option(c(\"-n\", \"--control_name\"), type=\"character\", help=\"the name of controls inside the variable/column to test against\", metavar=\"character\"),\n    make_option(c(\"-q\", \"--padjusted\"), type=\"double\", default=0.05, help=\"p-adjusted threshold value [default= %default]\", metavar=\"QVALUE\"),\n    make_option(c(\"-f\", \"--log_fold_change\"), type=\"double\", default=1, help=\"fold-change threshold value [default= %default]\", metavar=\"FOLD_CHANGE_THRESHOLD\"),\n    make_option(c(\"-s\", \"--subset\"), type=\"character\", help=\"Boolean formula to subset the input data\", metavar=\"character\"),\n    make_option(c(\"-m\", \"--model_organism\"), type=\"character\", help=\"the model organism to use during Gene Ontology step, eg Mus_musculus\", metavar=\"character\"),\n    make_option(c(\"-d\", \"--organism_library\"), type=\"character\", help=\"the R DB/library of the model organism to use during Gene Ontology step, e.g. org.Mm.eg.db for Ensembl version of Mus musculus\", metavar=\"character\")\n);\n\nopt_parser = OptionParser(option_list=option_list);\nopt = parse_args(opt_parser);\n\nif (is.null(opt$phenodata))\n    stop(\"Phenodata parameter must be provided (-p). See script usage (--help)\")\n\nif (is.null(opt$outdir))\n    stop(\"Output directory parameter must be provided (-o). See script usage (--help)\")\n\nif (is.null(opt$var_to_test))\n    stop(\"Variable to test parameter must be provided (-v). See script usage (--help)\")\n\nif (is.null(opt$control_name)){\n    print(\"Using lexicographic order of values in column VAR_TO_TEST instead of custom label (e.g., 'control') for differential analysis\")\n} else {\n    print(paste(\"Using\", opt$control_name, \"as control value for differential analysis\"))\n}\n\n    \nPHENO_DATA = opt$phenodata\nSEPARATOR = opt$separator\nPATH = opt$outdir\nif (is.null(PATH)) PATH = \"./\"\nGENE_COUNTS = opt$gene_counts\nVAR_TO_TEST = opt$var_to_test\nSUBS = opt$subset\nCONTROL_NAME = opt$control_name\nPADJ = opt$padjusted                 #Set the PADJ value cutoff\nFC_THR = opt$log_fold_change            #Set the log2FC value cutoff\nORGANISM=opt$model_organism\nORGANISM_LIBRARY = opt$organism_library    # \"org.Mm.eg.db\"\n\n\n# Saving parameters to file\nwrite.table(t(as.data.frame(opt)), file=paste(PATH, \"parameters.txt\", sep=\"\"))\n\nprint(\"Loading DESeq2 package\")\nlibrary(\"DESeq2\")\n\n###################################\n#######  DATA IMPORT ##############\n###################################\nprint(paste(\"Reading gene counts from \", GENE_COUNTS))\n\ncountData <- as.matrix(read.csv(GENE_COUNTS, row.names=\"gene_id\"))\nprint(paste(\"Reading phenodata from \", PHENO_DATA))\ncolData <- read.csv(PHENO_DATA, sep=SEPARATOR, row.names=1)\n\n#qualche check preliminare. Devo avere due TRUE per poter continuare:\nprint(\"Do phenodata and gene count matrix refer to the same set of samples?\")\nall(rownames(colData) %in% colnames(countData))\n#[1] TRUE\ncountData <- countData[, rownames(colData)]\nall(rownames(colData) == colnames(countData))\n#[1] TRUE\n\n\n###################################\n#######  DATA SUBSET AND PRE-FILTERING ##############\n###################################\n\n## Come d'accordo con i ricercatori (Arianna Rinaldi),\n## costruisco a monte la stringa per il subset che abbia un aspetto come questa:\n## SUBS <- quote(condition==\"drought\" | condition==\"watered\")\nif (! is.null(SUBS) )\n{\n#Posso cos\u00ec subsettare phenodata e matrice di conta:\ncolData_filt <- subset(colData, eval(parse(text = SUBS)))\ncountData_subs <- countData[,colnames(countData) %in% rownames(colData_filt)]\n} else {\ncolData_filt = colData\ncountData_subs = countData\n}\n\n\n#filering:\nprint(\"####### DATASET PRE-FILTERING ###########\")\nprint(\"Removing genes whose mean expression is less than 5 FPKM in at least 80% of the samples\")\n#Define a function to remove genes whose mean expression is less than 5 in at least 80% of the samples:\nfun <- kOverA(round(dim(colData_filt)[1]*80/100),5)\n#Apply it to my matrix:\nfilter1 <-  apply( countData_subs, 1, fun)\ncountData_filt <- countData_subs[filter1,]\n\n\n##Questo relevel non \u00e8 sempre fondamentale. Si pu\u00f2 saltare se non c'\u00e8 un vero e proprio campione di controllo (ad. es Pioppo, maiale). E' importante perch\u00e9 il segno del FC dipende da chi si trova al denominatore. Va invece utilizzato ad esempio nel caso dello stress laddove il valore di riferimento DEVE essere \"control\".\nif ( ! is.null(CONTROL_NAME) )\ncolData_filt[[VAR_TO_TEST]] <- relevel(colData_filt[[VAR_TO_TEST]], ref = CONTROL_NAME)\n\n###################################\n#######  DESeq2 ANALYSIS ###########\n###################################\n\n# Create a DESeqDataSet from count matrix and labels\n# (bisogna ricostruire nuovamente l'oggetto DESeq ogni volta che si cambia il design!)\ndds <- DESeqDataSetFromMatrix(countData = countData_filt, colData = colData_filt, design = as.formula(paste(\"~\", VAR_TO_TEST)))\n\n# Run the default analysis for DESeq2 and generate results table\ndds <- DESeq(dds)\nres <- results(dds)\n\n# Sort and filt  by adjusted p-value:\nresOrdered <- res[order(res$padj), ]\n\n# Computing and Exporting only the results which pass an adjusted p value threshold and a particular FC value:\n# First of all, we need to subset the matrix:\nresSig <- subset(resOrdered, padj < PADJ & abs(log2FoldChange)>=FC_THR)\n\n###################################\n#########  DATA SAVE  ##############\n###################################\n\n#####################################################\n### Compose the output file's name in a parametric manner. ###\n#####################################################\n# This string gives a short summary of the tested categories and I parse and use it in the output's name:\ntested_cat <- resSig@elementMetadata@listData$description[5]\ntested_cat <- gsub(\"Wald test p-value: \", \"\" , tested_cat)\n\nCONDITION_STRING = paste(\"qvalue\", PADJ, \"log2FC\", FC_THR, gsub(\" \",\"_\",tested_cat), sep=\".\")\n\n\n\n\n\n\n###########################################\n###################GENE ONTOLOGY#########\n###########################################\nlibrary(ORGANISM_LIBRARY, character.only=TRUE) #Genome wide annotation for Mouse, primarily based on mapping using Entrez Gene identifiers.\norgdb <- ORGANISM_LIBRARY\nlibrary(clusterProfiler)\nlibrary(AnnotationHub)\nhub <- AnnotationHub()\nquery(hub, ORGANISM)\n\n#Gene Ontology for Cellular Components:\nCC <- enrichGO(gene = rownames(resSig), OrgDb=orgdb, keyType=\"SYMBOL\", ont =\"CC\", pAdjustMethod =\"fdr\", qvalueCutoff = 0.05)\nCC_enriched_GO_terms <- data.frame(CC$ID, CC$geneID, CC$p.adjust)\nwrite.csv(CC_enriched_GO_terms, file=paste(paste(PATH,\"/\", sep=\"\"), \"CC_enriched_GO_terms.\", CONDITION_STRING, \".csv\", sep=\"\"), row.names=F)\n\n\n#Gene Ontology for Biological processes DEGs are involved in:\nBP <- enrichGO(gene = rownames(resSig), OrgDb=orgdb, keyType=\"SYMBOL\", ont =\"BP\", pAdjustMethod =\"fdr\", qvalueCutoff = 0.05)\nBP_enriched_GO_terms <- data.frame(BP$ID, BP$geneID, BP$p.adjust)\nwrite.csv(BP_enriched_GO_terms, file=paste(paste(PATH,\"/\", sep=\"\"), \"BP_enriched_GO_terms.\", CONDITION_STRING, \".csv\", sep=\"\") , row.names=F)\n\n#Gene Ontology for Molecular Functions:\nMF <- enrichGO(gene =  rownames(resSig), OrgDb=orgdb, keyType=\"SYMBOL\", ont =\"MF\", pAdjustMethod =\"fdr\", qvalueCutoff = 0.05)\nMF_enriched_GO_terms <- data.frame(MF$ID, MF$geneID, MF$p.adjust)\nwrite.csv(MF_enriched_GO_terms, file=paste(paste(PATH,\"/\", sep=\"\"), \"MF_enriched_GO_terms.\", CONDITION_STRING, \".csv\", sep=\"\") , row.names=F)\n\n\n###################################\n######### GRAPHICAL PART #########\n###################################\nif(nrow(CC_enriched_GO_terms)!=0)\n{\nmyplot <- dotplot(BP, font.size= 14)\npng(file=paste(PATH, \"dotplot_BP_enriched_GO_terms.\", CONDITION_STRING, \".png\", sep=\"\"), width = 780, height = 480)\nprint(myplot)\ndev.off()\n} else {\nprint(\"No enriched go terms for Biological Process: no plot produced\")\n}\n\nif(nrow(MF_enriched_GO_terms)!=0)\n{\nmyplot <- dotplot(MF, font.size= 14)\npng(file=paste(PATH, \"dotplot_MF_enriched_GO_terms.\", CONDITION_STRING, \".png\", sep=\"\"),width = 780, height = 480)\nprint(myplot)\ndev.off()\n} else {\nprint(\"No enriched go terms for Molecular Function: no plot produced\")\n}\n\nif(nrow(MF_enriched_GO_terms)!=0)\n{\nmyplot <- dotplot(CC, font.size= 14)\npng(file=paste(PATH, \"dotplot_CC_enriched_GO_terms.\", CONDITION_STRING, \".png\", sep=\"\"), width = 980, height = 480)\nprint(myplot) \ndev.off()\n} else {\nprint(\"No enriched go terms for Molecular Function: no plot produced\")\n}", 
            "filename": "create_ontology_tables.R"
        }
    ], 
    "skip": false, 
    "command_level": "top", 
    "overwrite": false, 
    "begin_block": "", 
    "hpc_directives_text": "", 
    "title": "produceDEGs", 
    "hpc_directives": {
        "account": "cin_staff", 
        "error": "", 
        "job_name": "", 
        "queue": "gll_usr_prod", 
        "dependencies": [
            "prepareCountMatrices"
        ], 
        "memory": {
            "size": "GB", 
            "quantity": 10
        }, 
        "output": "", 
        "nodes": 1, 
        "walltime": "24:00:00", 
        "cpu": 1, 
        "mpi_procs": 0
    }, 
    "description_short": "", 
    "checks": [], 
    "end_block": "", 
    "command_chunk_size": 1, 
    "script_level": "top", 
    "description": "", 
    "tags": [], 
    "commandline": "INPUT_FILE=\"phenodata.xlsx\"\nCONVERTED_INPUT_FILE=\"phenodata.converted.xlsx\"\nDATASET_FILE=\"dataset.xlsx\"\n\nCOVARIATE=\"Stress.protocol\"\nDATA_DIR=\"data/\"\nOUTPUT_DIR=\"degs/\"\nCOMBINATION_FILE=$OUTPUT_DIR\"subsets.txt\"\nCOLUMNS_TO_SKIP=\"ids,Estrus,Age.w,Replicate,ids,Note,Stress_added_T\"\nSHEETS_TO_SKIP=\"PRJNA392171,PRJNA341670,Codici\"\nTO_SKIP=\"Estrus,Age.w,Replicate,ids,Note,Stress_added_T\"\nCOLUMNS_2_VALUES=\"Time.from.stress.h,Phenotype,Treatment.2\"\nCOLUMNS_NOT_TO_MERGE=\"Time.from.stress.h,Region,Phenotype,Treatment.2,Sex\"\n\nORGANISM_NAME=\"Mus musculus\"\nORGANISM_DB=\"org.Mm.eg.db\"\n\nif [ ! -d $OUTPUT_DIR ]; then\n\tmkdir $OUTPUT_DIR\nfi\n\npython3 configuration_converter.py $INPUT_FILE $CONVERTED_INPUT_FILE $DATASET_FILE $SHEETS_TO_SKIP\npython3 configurator.py $CONVERTED_INPUT_FILE $COVARIATE $COLUMNS_TO_SKIP $TO_SKIP $COLUMNS_2_VALUES $COLUMNS_NOT_TO_MERGE > $COMBINATION_FILE\n\npython3.5 configuration_splitter.py $CONVERTED_INPUT_FILE $DATA_DIR $SHEETS_TO_SKIP\n\npython produce_lists_deseq2.py -n \"control\" -f $COMBINATION_FILE -i $DATA_DIR -o $OUTPUT_DIR -m $ORGANISM_NAME -d $ORGANISM_DB", 
    "executable": [], 
    "write_stdout_log": true, 
    "conditions": [], 
    "modules": [
        "r/3.4.2", 
        "python/3.5.2"
    ], 
    "write_stderr_log": true, 
    "command_group_level": "all", 
    "command_parallelism_level": "sequential"
}